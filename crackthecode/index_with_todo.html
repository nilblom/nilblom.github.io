<html>
	<head>
		<title>Nils Blomqvist's web page</title>
		<link rel="stylesheet" href="../style.css?v=202508011113">
		<script>

			function number_pre_lines(pres) {
				for (var i = 0; i < pres.length; i++) {
					var old_text = pres[i].innerText;
					var line_count = 0;
					pres[i].innerText = "";
					for (var j = 0; j < old_text.length; j++) {
						if (j == 0) {
							pres[i].innerText += line_count + " " + old_text[j];
							line_count++;
						} else if (old_text[j] == "\n") {
							pres[i].innerText += old_text[j] + line_count + " ";
							line_count++;
						} else {
							pres[i].innerText += old_text[j];
						}
					}
				}
			};

			document.addEventListener("DOMContentLoaded",  function() {
				// console.log("hi");
				var pres = document.querySelectorAll("pre");
				number_pre_lines(pres);
			});
		</script>
	</head>
	<body>
		<h1><a href="../">< home</a> Crack the Code</h1>

		<div style="background:red;border:1px solid;">
			<ul>
				<li>Can it be included in a book? How can I find someone interested. Contact a publisher.</li>
				<li>List of tables should not include program code</li>
				<li>Explain the solution using the tables</li>
				<li>Include a link to the program</li>
				<li>Make lock image JPG (small size)</li>
				<li>Change publishing date before publish</li>
			</ul>
		</div>

		<p>Timeline:</p>
		<ul>
			<li>2026-02-09: First published.</li>
		</ul>

		<p>The program can be downloaded <a href="./crackthecode.py">here</a>.

		<p>Table of Contents</p>
		<ol>
			<li><a href="#forewords">1. Forewords</a></li>
            <li><a href="#whatiscrackthecode">2. What is 'Crack the Code'?</li>
            <li><a href="#rules">3. Rules</a></li>
            <li><a href="#gamedictionary">4. Game dictionary</a></li>
            <li><a href="#examplegame">5. Example game</a></li>
        	<ol>
	            <li><a href="#tip1">5.1 Tip 1/4: x=2 y=1 314</a></li>
	            <li><a href="#tip2">5.2 Tip 2/4: x=0 y=0 560</a></li>
	            <ol>
        			<li><a href="#motivatingnegativehypotheses">5.2.1 Motivating the use of negative hypotheses</a></li>
        		</ol>
	            <li><a href="#tip3">5.3 Tip 3/4: x=1 y=0 214</a></li>
	            <li><a href="#tip4">5.4 Tip 4/4: x=2 y=1 387</a></li>
            	<li><a href="#">5.5 Combining hypotheses</a></li>
        	</ol>
            <li><a href="#programmingasolutionfinder">6. Programming a solution finder</a></li>
            <ol>
	            <li><a href="#creatingdatastructures">6.1 Creating data structures</a></li>
	            <li><a href="#programmingroutines">6.2 Programming routines</a></li>
	            <li><a href="#generatingtips">6.3 Generating tips</a></li>
	        </ol>
            <li><a href="#doyouhavequestions">7. Do you have questions about this writeup?</a></li>
        </ol>

        <p>List of tables</p>

        <ol>
        	<li><a href="#table1">5.1.1 Hypotheses for 314, x=2, y=1</a></li>
        	<li><a href="#table2">5.2.1 Hypotheses for 560, x=0, y=0</a></li>
        	<li><a href="#table3">5.3.1 Hypotheses for 214, x=1, y=0</a></li>
        	<li><a href="#table4">5.4.1 Hypotheses for 387, x=2, y=1</a></li>
        	<li><a href="#table5">6.2.1 Main function of the program</a></li>
        	<li><a href="#table6">6.2.2 Function for combining hypotheses</a></li>
        	<li><a href="#table7">6.2.3 Function for checking compatibility</a></li>
        	<li><a href="#table8">6.2.4 Function for creating hypotheses from tips</a></li>
        	<li><a href="#table9">6.2.5 Functions for mirroring and creating negative codes in hypotheses</a></li>
        	<li><a href="#table10">6.2.1.1 Function for generating tips</a></li>
        </ol>

		<center><img src="padlock.png" width="200px"/></center>

		<h1 id="forewords">1. Forewords</h1>

		<p>I started to build a program that can solve games of 'Crack the Code' mid November 2025. By late January 2026 the theory and the program both seem to work. Crack the Code is a game that I found several math groups on Facebook were posting.</p>

		<p>The method that is used in this article to crack the given code is similar to what I would do without pen and paper, although much more rigorous.</p>

		<h1 id="whatiscrackthecode">2. What is 'Crack the Code'?</h1>

		<p>'Crack the Code' is a game where a secret code is cracked with the help of tips that show how
		parts of the code is formed.</p>
		
		<h1 id="rules">3. Rules</h1>
		<ul>
			<li>The game starts by player one coming up with a secret code (three unique numbers). The same player then writes a series of tips (typically 4).</li>
			<li>The code is a three-digit number (variants of the game where there are less or more than this exist).</li>
			<li>The other player uses the tips to figure out what the secret code is (there may be multiple solutions).</li>
			<li>The tips must together contain each digit that is in the secret code.</li>
			<li>Each tip typically indicate a part of the code. There are three components to a tip: 1) the digits (as many as there are in the secret code) 2) a number that indicate how many of the digits are also in the secret code 3) a number that indicate how many of the digits are correctly placed relative to the secret code.</li>
		</ul>

		<h1 id="gamedictionary">4. Game dictionary</h1>
		<ul>
			<li>secret code: A three-digit (all unique) number that is only known to one of the players.</li>
			<li>digit: One of the elements in a code. For example, 1 in [1, 2, 3] is a digit.</li>
			<li>tip: The three elements “number of digits in the code” (<i>x</i>), “number of correctly placed digits in the code” (<i>y</i>) and the digits that the previous two statements applies for (see <i>tip code</i>). x is always equal to or greater than y.
			<li>x: See <i>tip</i>.</li>
			<li>y: See <i>tip</i>.</li>
			<li>tip code: The three-digit code used in a tip. It usually contains one or more digits from the secret code.</li>
			<li>hypothesis: A list of one <i>positive hypothesis</i> and zero or more <i>negative hypotheses</i>.</li>
			<li>positive hypothesis: Something resembling a <i>tip code</i>. It codes a guess or <i>hypothesis</i> about the structure and content of the <i>secret code</i>.</li>
			<li>negative hypothesis: It has the same structure as a <i>positive hypothesis</i>, but the negative hypothesis expresses what forms the secret code cannot take.</li>
			<li>solution: A set of hypotheses that produces the secret code (or one of the secret codes).</li>
			<li>grand hypothesis: A set of hypotheses that may be a solution.</li>
		</ul>

		<h1 id="examplegame">5. Example game</h1>

		<p>The secret code is 348. The list of tips (x, y, digits) are:</p>
		<ul>
			<li>2 1 314</li>
			<li>0 0 560</li>
			<li>1 0 214</li>
			<li>2 1 387</li>
		</ul>
		<p>From the tips above, it is possible to reach the conclusion that 348 is the secret code. I will present details about each tip below. One way to solve the game methodically is to create hypotheses about what the code can look like and then combine them together. I will use a method that does this, which is also one I came up with. (This is also the method that I have implemented in a Python program that is available for download on this page.) I have marked in black the hypotheses (partial solutions) that solve this particular example game.</p>

		<h2 id="tip1">5.1 Tip 1/4: x=2 y=1 314</h2>

		<p>From x and y one can tell that of 3, 1, and 4 only two are in the secret code, and that one of them is in the correct position. It is not possible to know which the digits are, but by creating hypotheses it is possible to solve the game.</p>

		<p>I start creating hypotheses by assuming that the digit 3 is in the correct position, then 1, then 4 (in each column, see the table below). But since x=2 I have to add another number to my hypotheses. I start with 1 since it is the next number in the code. With 3 fixed and 1 being the other digit, there is only one option: 3_1. The other (31_) has two digits matching the positions in the tip code, so it must be discarded because of the requirement set by y. Choosing 3 and 4, 34_ is the possible option. 3_4 cannot be possible since it would also imply that y=2.</p>

		<p>Having assumed that 3 is the cause of y=1, it's time to move on to the second digit: 1. 31_ and  _14 are not valid, but _13 and 41_ are. The reasoning is the same as in the previous paragraph.</p>

		<p>Moving on to using 4 as the correctly placed digit, the possible hypotheses are _34, and 1_4. With the secret code already revealed, it is possible to see the partial solution from the first tip that matches the code: 34_ (see the black cell).</p>

		<p>Hypotheses that possibly fulfil these requirements are in the table below. The cells of impossible hypotheses have been colored red.</p>

		<figure>
		<table id="table1" border=1px style="caption-side: bottom;font-family: monospace;">
			<caption>Hypotheses for 314, x=2, y=1.</caption>
		<tr>
			<td style="background:red;">31_ (__4,)</td><td style="background:red;">31_ (__4,)</td><td>_34 (1__,)</td>
		</tr>
		<tr>
			<td>3_1 (_4_,)</td><td>_13 (4__,)</td><td style="background:red;">3_4 (_1_,)</td>
		</tr>
		<tr>
			<td style="color: white; background: black;">34_ (__1,)</td><td>41_ (__3,)</td><td style="background:red;">_14 (3__,)</td>
		</tr>
		<tr>
			<td style="background:red;">3_4 (_1_,)</td><td style="background:red;">_14 (3__,)</td><td>1_4 (_3_,)</td>
		</tr>
		</table>
		</figure>

		<h2 id="tip2">5.2 Tip 2/4: x=0 y=0 560</h2>

		<p>A tip where x=0, y=0 can be interpreted as an empty positive hypothesis. Any digit may occur except for the ones in the tip code. To express that, negative hypotheses are created. It is enough to create hypotheses such that each digit has occupied every slot in total (you can do this by rotating the number three times). Why is it enough? The x=0 y=0 type tips express that each number in the tip code may not occur in any position in the code. If one creates negative hypotheses where each digit has (in total) occupied every position, the same idea has been expressed.</p>

		<h2 id="motivatingnegativehypotheses">5.2.1 Motivating the use of negative hypotheses</h2>

		<p>In an example where two of the tips are 1 1 123 and 2 2 423, the use of negative hypotheses have the effect of discarding incompatible hypotheses. Consider the hypothesis 1__ (from the first tip). It would be considered compatible with _23 (from the second tip) if the negative hypotheses _23 from the first tip is not taken into account. If _23 would be the right choice, the first tip should say 3 3 123, since also 2 and 3 are in the correct positions. Therefore negative hypotheses are necessary. Can you spot more situations when it would come into effect in the example game?</p>

		<figure>
		<table id="table2" border=1px style="caption-side:bottom;font-family: monospace;">
		<caption>Hypotheses for 560, x=0, y=0.</caption>
		<tr>
			<td style="color: white; background: black;">___ (650, 065, 506)</td>
		</tr>
		</table>
		</figure>

		<h2 id="tip3">5.3 Tip 3/4: x=1 y=0 214</h2>

		<p>In this tip, only one digit in the tip code is in the secret code. And it is not in the correct position. I have started by assuming that 2 is that number (in the first row), then 1 (in the second row), and then 4 (in the third row). In each hypothesis, the number takes a place that is not the place of the number in the tip code.</p>

		<p>If you peek at the hypotheses, you can see that the correct one was found. It is correct because you can combine _4_ with 348 without conflict. Both hypotheses say that the 4 should be in the middle position.</p>

		<figure>
		<table id="table3" border=1px style="caption-side: bottom;font-family: monospace;">
			<caption>Hypotheses for 214, x=1, y=0.</caption>
		<tr>
			<td>_2_ (1_4, 4_1,)</td><td>1__ (_24, _42,)</td><td>4__ (_21, _12,)</td>
		</tr>
		<tr>
			<td>__2 (43_, 34_,)</td><td>__1 (24_, 42_,)</td><td style="color: white; background: black;">_4_ (2_1, 1_2,)</td>
		</tr>
		</table>
		</figure>

		<h2 id="tip4">5.4 Tip 4/4: x=2 y=1 387</h2>

		<p>The reasoning to create hypotheses for this tip is the same as for the previous tips.</p>

		<figure>
		<table id="table4" border=1px style="caption-side: bottom;font-family: monospace;">
			<caption>Hypotheses for 387, x=2, y=1.</caption>
		<tr>
			<td style="background:red;">38_ (__7,)</td>
			<td style="background:red;">38_ (__7,)</td>
			<td>37_ (__8,)</td>
		</tr>
		<tr>
			<td style="color: white; background: black;">3_8 (_7_,)</td>
			<td>_83 (7__,)</td>
			<td>_73 (8__,)</td>
		</tr>
		<tr>
			<td>37_ (__8,)</td>
			<td>78_ (__7,)</td>
			<td style="background:red;">87_ (__3,)</td>
		</tr>
		<tr>
			<td style="background:red;">3_7 (_8_,)</td>
			<td style="background:red;">_87 (3__,)</td>
			<td>_78 (3__,)</td>
		</tr>
		</table>
		</figure>

		<h2 id="combininghypotheses">5.5 Combining hypotheses</h2>

		Like you saw in the previous sections, hypotheses have been noted for each of the four tips. They can now be combined in different ways to form grand hypotheses. One (or sometimes several) of them are solutions while others are not.

		Only hypotheses that are compatible with each other can be combined to form a grand hypotheses. Compatability can be defined as a function that takes two or more hypotheses and makes a series of comparisons between the two. It works like this: pick a digit from one of the positive hypotheses. It should be in the first position. For all other positive hypotheses, it should be the case that the value in the same position is equal to that digit or is blanked. For all negative hypotheses it should be the case that the position is blanked or is not held by the same digit.

		Once you have understood the concept of compatible hypotheses, it is relatively easy to pick out compatible ones that form a solution from the tables above simply with your eye.

		<h2 id="programmingasolutionfinder">6. Programming a solution finder</h2>

		<p>The method used so far is enough of a method that it can be programmed into a computer program.</p>

		<p>One thing that was not addressed in the previous sections is how to in practice combine the hypotheses and decide if they are all compatible with each other (the goal here is to find out if they can form a solution). To programmatically find the solutions from the lists of hypotheses, we can create the cartesian product of the four tables. It involves finding every combination of one hypotheses from each table. Then it is a matter of computing if they are compatible or not. If all hypotheses are compatible with each other (see <a href="#combininghypotheses">Combining hypotheses</a>), a grand hypothesis is also a solution.</p>

		<p>There is also the possibility to, at each step of combining a hypotheses with one from the next table, checking for compatibility. That way the computer never creates grand hypotheses that are not solutions, thus saving power. Because the items that need to be combined are relatively few, there is less gain to be had compared to if the items were in the thousands, ten-thousands or hundreds of thousands.</p>

		<p>Let's move on to how to complete the program. To start with, in order to write a program that can solve Crack the Code, the input to the program (the tips) must be coded for the computer. I decided to use the Python programming language because of its simplicity. The following sections are easier to follow if you have already learned Python.</p>

		<h3 id="creatingdatastructures">6.1 Creating data structures</h3>

		<p>A tip can easily be coded using a tuple. The properties <i>x</i> and <i>y</i> can occupy the first two positions. The tip code, <i>a</i> in the programming code, can occupy the third position. It is easy to reference to each digit in the code if it is split into digits and put in a list. The result looks like [1, 0, [3, 1, 4]].</p>

		<p>Hypotheses may contain both positive and negative hypotheses. Their structure is similar to the secret code and tip code, but they may contain blanks as in [1, "_", 3]. To distinguish positive and negative hypothesis, I put a zero (negative hypothesis) or one (positive hypothesis) in front of the digits. The positive hypotheses looks like [1, [3, 4, "_"]], and a negative hypotheses looks like [0, ["_", "_", 1]]. From this, a complete hypotheses therefore looks like ([1, [3, 4, "_"]], [0, ["_", "_", 1]]).

		<h2 id="programmingroutines">6.2 Programming routines</h2>

		<p>The main routine is simple: first hypotheses are created from the tips, and then they are combined. At the end (lines 12-13) it is made sure that only unique solutions are returned by the function. Checking if a solution is unique is done by simplifying the grand hypothesis into its simpler form [a, b, c] (line 9, 18-27). Because solutions may be incomplete (one of the slots that should hold a digit may not), solutions are checked for completeness (line 10). Checking the lists of hypotheses for uniqueness would never result in a duplicate. Can you guess why?</p>

		<figure id="table5">
		<pre>
def crackthecode(tips):
	hypotheses = []
	for tip in tips:
		hypotheses.append(list(infer(tip[0], tip[1], tip[2])))
	
	solutions = combine(hypotheses)
	unique_solutions = []
	
	for s in solutions:
		t = simple_form(s)
		if not solution_is_complete(t):
			continue
		if not t in unique_solutions:
			unique_solutions.append(t)

	return unique_solutions


def simple_form(solution):
	simple = [-1, -1, -1]
	for hyp in solution:
		hyp = hyp[0]
		if hyp[0] == 0:
			continue
		for i in range(3):
			if hyp[1][i] != "_":
				simple[i] = hyp[1][i]		
	return simple


def solution_is_complete(simple_form):
	if -1 in simple_form:
		return False
	return True</pre>
		<caption>The main function of the program and the function that simplifies a grand hypothesis.</caption>
		</figure>

		<p>Below is how hypotheses are combined into grand hypotheses. <i>itertools.product()</i> from the Python standard library is used, with a call to check if the solution is compatible before yielding the result. It is possible to use a custom implementation of itertools.product() or use the function in more creative ways to remove partial solutions that don't fit early on instead of continue adding hypotheses to form a grand hypothesis. It should be possible to save more than half of the comparisons, since more than half of the products are solutions. As I mentioned, implementing that option is a fun exercise.</p>

		<figure id="table6">
		<pre>
def combine(H):
	combinations = product(*H)
	for c in combinations:
		if solution_fits(c):
			yield c</pre>
		<caption>The function that combines hypotheses.</caption>
		</figure>

		<p>The function that check for compatibility of hypotheses is shown below. It uses the fact that you can line up all the hypotheses, positive and negative, and for each position of the digits, pick the first occurring digit among the positive hypotheses. All positive hypotheses must then either have a "_" or the same digit that was found earlier in that position in order for it to be a solution. All negative hypotheses must have a different digit or a "_". The same method is applied to all of the positions that a digit in the code can have (1, 2, 3).</p>

		<figure id="table7">
		<pre>
def solution_fits(solution):
	for i in range(3):
		a = None

		def find_digit():
			for h in solution:
				for x in h:
					if x[0] == 1 and x[1][i] != "_":
						return x[1][i]

		a = find_digit()
		for h in solution:
			for x in h:
				if x[0] == 1:
					if x[1][i] != a and x[1][i] != "_":
						return False
				elif x[0] == 0:
					if x[1][i] == a and x[1][i] != "_":
						return False
	return True</pre>
		<caption>Functions to check for compatibility of hypotheses.</caption>
		</figure>

		<p>The function that creates hypotheses from the tips require some explanation. If x=0 then only negative hypotheses need to be created (with the obligatory empty positive hypotheses). The function <i>negative_hypotheses()</i> can be seen below <i>infer()</i>.</p>

		<p>For each permutation of the tip code (there are 3!=6 of them if the digits are unique), combinations of size x (for example [3, 1], [3, 4], [1, 4] for [3, 1, 4] and x=2) are created from the tip code (line 16). The digit that is not in the combination is blanked with an underscore (the loop at line 14 and lines 28-29). The excluded digit is then added to the negative hypotheses (line 30). Once each digit in the permutation has been examined, the altered permutation is tested for the requirement that y makes (lines 32-33). If it does not pass (y should be equal to the number of correctly placed digits) the permutation is discarded. In the for-loop (lines 25-26), a count is increased whenever a digit occurs that is both in the combination and is in the same position as the same digit in the tip code.</p>

		<p>At the end of the for-loop, the hypothesis is added, with its negative hypothesis and if one exists, the mirrored negative hypothesis (lines 42-45). Negative hypotheses have already been motivated in <a href="#motivatingnegativehypotheses">Motivating the use of negative hypotheses</a>. The mirrored negative hypothesis exists to express that the numbers in the negative hypothesis cannot occur in either combination. For example the negative hypothesis _30 has a mirror _03. A mirrored negative hypothesis is only created when x=1, so that two digits are excluded in the negative hypothesis. If x=2, there is only one position in the negative hypothesis where a digit can be so there is nothing to mirror. If x=3 the early lines of code in <i>infer()</i> creates the different (the rotations) negative hypotheses. The hypotheses is also tested for uniqueness (lines 35-38). It may be that after blanking digits, two permutations look the same. For example, see 38_ in <a href="#table4">Table 4</a>.</p>

		<figure id="table8">
		<pre>
def infer(x, y, a):
	if x < y:
		raise Exception("x must be equal to or greater than y")

	if x == 0:
		H = [ [[1, ["_", "_", "_"]]] ]
		n = list(negative_hypotheses(a))
		for h in n:
			H[0].append([0, h])
		return H

	P = list(permutations(a))
	results = []
	seen_positive_hypotheses = []
	for permutation in P:
		b = list(permutation)
		C = list(combinations(b, x))

		for combination in C:
			combination = list(combination)
			c = copy.copy(b)
			correctly_placed = 0
			exclude = [0, ["_", "_", "_"]]

			for number in range(3):
				if c[number] in combination and c[number] == a[number]:
					correctly_placed += 1

				if c[number] not in combination:
					c[number] = "_"
					exclude[1][number] = c[number]

			if correctly_placed != y:
				continue

			if c in seen_positive_hypotheses:
				continue

			seen_positive_hypotheses.append(c)

			c = [1, c]

			if mirror_numbers(exclude[1]):
				results.append((c, exclude, [0, mirror_numbers(exclude[1])]))
			else:
				results.append((c, exclude))

	return results</pre>
		<caption>The function that creates hypotheses from one of the code tips.</caption>
		</figure>

		<p>To create the negative hypotheses from a tip code <i>a</i>, it is rotated three times (line , each time yielding a result.</p>

		<figure id="table9">
		<pre>
def negative_hypotheses(a):
	q = deque(a)
	for i in range(3):
		q.rotate(1)
		yield list(q)

def mirror_numbers(a):
	numbers = []
	b = copy.copy(a)
	for i in range(3):
		if a[i] != "_":
			numbers.append(a[i])
	for i in range(3):
		if a[i] != "_":
			b[i] = numbers.pop(-1)
		else:
			b[i] = "_"
	if b == a:
		return None
	return b</pre>
		<caption>Functions for creating the codes in a negative hypotheses and mirroring the numbers of a negative hypotheses.</caption>
		</figure>

		<h3 id="generatingtips">6.2.1 Generating tips</h3>

		<p>The program would not be complete without a routine to create a new set of tips that, of course, the program can solve. The code below creates a set of tips for a given code (in other words, you come up with the code and the tips are created for you).</p>

		<p>The while-loop (line 17) loops 4 times to create four tips. Each time, three numbers are selected at random from a <i>pool</i> (line 20-22) (each number can only be picked once, like a pool of water where water actually is removed if you take some out). x and y are inferred from the randomly selected numbers using the inner functions <i>infer_x()</i> (line 2) and <i>infer_y()</i> (line 9).</p>

		<figure id="table10">
		<pre>
def generate_tips(code):

	def infer_x(code, a):
		x = 0
		for number in a:
			if number in code:
				x += 1
		return x

	def infer_y(code, a):
		y = 0
		for i in range(3):
			if code[i] == a[i]:
				y += 1
		return y

	tips = []
	while len(tips) < 4:
		pool = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

		numbers = [pool.pop(random.randint(0, len(pool)-1)),
			pool.pop(random.randint(0, len(pool)-1)),
			pool.pop(random.randint(0, len(pool)-1))]
		
		x = infer_x(code, numbers)
		y = infer_y(code, numbers)

		tips.append((x, y, numbers))

	return tips</pre>
	<caption>A Python routine to generate four tips; you give it the secret code that you want.</caption>
	</figure>


		<h1 id="doyouhavequestions">7. Do you have questions about this writeup?</h1>

		<p>Please send your questions to <a href="mailto:nblomqvist834@gmail.com">nblomqvist834@gmail.com</a>.</p>

	</body>
</html>